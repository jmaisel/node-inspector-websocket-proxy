# Debugger v2 - Quick Start Guide

## üöÄ Getting Started

### Running the Complete Application

**URL**: http://localhost:8080/debugger-v2/debugger.html

The complete debugger application is now live with:
- ‚úÖ Dockable toolbar with connection controls
- ‚úÖ Tab system (Console, Call Stack, Files, Breakpoints, Watches, Scope)
- ‚úÖ All UI components rendering dynamically
- ‚úÖ Event-driven architecture

### What's Different from v1?

| Feature | v1 | v2 |
|---------|----|----|
| HTML | Hardcoded in debugger.html | Generated by views |
| IDs | Fixed (`#toolbar`) | Unique (`#toolbar-a3f9k2`) |
| Embedding | Full page only | Mount anywhere |
| Templates | Not customizable | Override via registry |
| Multiple Instances | Not supported | Fully supported |

## üì¶ Embedding in Your Application

### Option 1: Use Individual Components

```javascript
import { ConsoleView } from './debugger-v2/index.js';

// Create and mount console
const consoleView = new ConsoleView({
    container: '#my-console-area',
    initialState: { mode: 'standalone' }
});

await consoleView.mount();

// Add log entries
consoleView.addLogEntry({
    message: 'Application started',
    type: 'info',
    timestamp: new Date().toLocaleTimeString()
});
```

### Option 2: Use Controllers

```javascript
import { ConsoleController } from './debugger-v2/index.js';

const console = new ConsoleController({
    container: '#my-area',
    exposeGlobally: true // Adds window.log()
});

await console.initialize();

// Use global log function
window.log('Hello from console!', 'info');
```

### Option 3: Custom Template

```javascript
import { TemplateRegistry, ToolbarView } from './debugger-v2/index.js';

// Register custom template BEFORE creating view
TemplateRegistry.register('toolbar', (data, config, instanceId) => {
    const elementMap = {
        container: instanceId,
        connectBtn: `${instanceId}-connect-btn`,
        wsUrlInput: `${instanceId}-ws-url`
    };

    return `
        <div id="${elementMap.container}" class="my-custom-toolbar">
            <input id="${elementMap.wsUrlInput}" value="${data.wsUrl}">
            <button id="${elementMap.connectBtn}">Connect</button>
        </div>
    `;
});

// Create view with custom template
const toolbar = new ToolbarView({ container: '#toolbar-area' });
await toolbar.mount();
```

## üéØ Element Map API

The element map provides access to all DOM elements in a view:

```javascript
const view = new ConsoleView({ container: '#my-console' });

// Before mount: Get selectors
const selectors = view.getElementMap();
console.log(selectors.searchInput); // '#console-abc123-search-input'

// After mount: Get DOM elements
await view.mount();
const elements = view.getElementMap();
console.log(elements.searchInput); // <input#console-abc123-search-input>

// Use elements directly
elements.searchInput.value = 'my search';
$(elements.clearBtn).click();
```

## üîß Available Components

### Core Infrastructure
- **BaseView** - Abstract base for all views
- **DockableView** - Extends BaseView with docking behavior
- **TemplateRegistry** - Global template override registry
- **ViewUtils** - Shared utilities (ID generation, HTML escaping, etc.)

### Views (8 components)
1. **ToolbarView** - Connection and debug controls
2. **ConsoleView** - Log display with search
3. **TabSystemView** - Tab navigation
4. **FileTreeView** - File browser
5. **CallStackView** - Stack frame display
6. **BreakpointListView** - Breakpoint management
7. **WatchesView** - Watch expressions
8. **ScopeView** - Variable inspection

### Controllers (8 components)
Each view has a corresponding controller that handles business logic:
- ToolbarController
- ConsoleController
- TabSystemController
- FileTreeController
- CallStackController
- BreakpointController
- WatchesController
- ScopeController

## üìñ Common Patterns

### Creating Multiple Instances

```javascript
// Create two independent consoles
const console1 = new ConsoleView({ container: '#console-1' });
const console2 = new ConsoleView({ container: '#console-2' });

await Promise.all([
    console1.mount(),
    console2.mount()
]);

// Each has unique IDs - no collisions!
console.log(console1.getInstanceId()); // 'console-a3f9k2'
console.log(console2.getInstanceId()); // 'console-x7m2n9'
```

### Handling Events

```javascript
import { ToolbarController } from './debugger-v2/index.js';

const toolbar = new ToolbarController({
    container: '#toolbar',
    wsUrl: 'ws://localhost:8888'
});

await toolbar.initialize();

// Listen to toolbar events
toolbar.on('connect', (wsUrl) => {
    console.log('Connecting to:', wsUrl);
    // Your connection logic here
});

toolbar.on('pause', () => {
    console.log('Pause requested');
    // Your pause logic here
});
```

### State Management

```javascript
const view = new ConsoleView({
    container: '#console',
    initialState: {
        searchExpanded: true,
        logEntries: []
    }
});

await view.mount();

// Update state (triggers re-render)
view.update({
    searchExpanded: false,
    logEntries: [
        { message: 'New log', type: 'info' }
    ]
});

// Get current state
const state = view.getState();
console.log(state.searchExpanded); // false
```

## üîç Inspecting Element Maps

To see what elements a view expects in custom templates:

```javascript
const view = new ToolbarView({ container: '#toolbar' });

// Get element map before mounting (returns selectors)
const map = view.getElementMap();
console.log(map);
// {
//   container: '#toolbar-abc123',
//   connectBtn: '#toolbar-abc123-connect-btn',
//   disconnectBtn: '#toolbar-abc123-disconnect-btn',
//   wsUrlInput: '#toolbar-abc123-ws-url',
//   // ... all other elements
// }
```

This shows you what IDs your custom template must include!

## üé® Styling

Debugger v2 uses the same CSS classes as v1 for compatibility:

```html
<!-- The original styles work automatically -->
<link rel="stylesheet" href="../debugger/styles.css">
```

Key classes:
- `.toolbar` - Toolbar container
- `.toolbar-btn` - Toolbar buttons
- `.console-container` - Console container
- `.tab-system` - Tab system
- `.file-tree` - File tree
- `.call-stack` - Call stack

## üß™ Testing

```javascript
// Example: Test console logging
import { ConsoleController } from './debugger-v2/index.js';

const console = new ConsoleController({
    container: document.body,
    exposeGlobally: true
});

await console.initialize();

// Test different log types
window.log('Info message', 'info');
window.log('Warning message', 'warning');
window.log('Error message', 'error');
window.log({ foo: 'bar' }, 'object');
```

## üìö Next Steps

1. **Explore the examples**: `/debugger-v2/examples/standalone-console.html`
2. **Read the full docs**: `/debugger-v2/README.md`
3. **Check the implementation summary**: `/debugger-v2/IMPLEMENTATION-SUMMARY.md`
4. **View deployment status**: `/debugger-v2/DEPLOYMENT-STATUS.md`

## üêõ Debugging

### Check if view is mounted
```javascript
console.log(view.isMounted()); // true/false
```

### Inspect element map after mount
```javascript
await view.mount();
const elements = view.getElementMap();
console.log('Missing elements:', Object.entries(elements)
    .filter(([k, v]) => !v)
    .map(([k]) => k)
);
```

### Validate template compatibility
```javascript
// The view will warn if elements are missing after mount
await view.mount();
// Check console for warnings like:
// "toolbar view is missing elements: pauseBtn, resumeBtn"
```

## üí° Tips

1. **Always register templates BEFORE creating views**
   ```javascript
   TemplateRegistry.register('toolbar', myTemplate);
   const view = new ToolbarView(config); // Uses myTemplate
   ```

2. **Use element maps for integration**
   - They show what IDs your custom templates need
   - They provide direct DOM access after mount

3. **Controllers handle business logic**
   - Views only handle DOM rendering
   - Controllers bind events and manage state

4. **Each instance has unique IDs**
   - Multiple instances work without conflicts
   - IDs follow pattern: `{component}-{random}`

5. **CSS classes are compatible**
   - Original styles.css works with v2
   - Classes remain the same as v1

## üéâ Success!

The debugger-v2 system is ready for:
- ‚úÖ Third-party embedding
- ‚úÖ Template customization
- ‚úÖ Multiple instances
- ‚úÖ Protocol integration
- ‚úÖ Production use

**Visit**: http://localhost:8080/debugger-v2/debugger.html to see it in action!
