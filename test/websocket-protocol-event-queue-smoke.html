<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebsocketProtocolEventQueue Smoke Tests</title>
    <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css">
</head>
<body>
    <div id="mocha"></div>

    <!-- Load testing frameworks first -->
    <script src="https://unpkg.com/mocha@10.2.0/mocha.js"></script>
    <script src="https://unpkg.com/chai@4.3.10/chai.js"></script>

    <!-- Load application code -->
    <script src="../client/regex-pubsub.js"></script>
    <script src="../client/inspector-constants.js"></script>
    <script src="../client/inspector-controllers.js"></script>
    <script src="../client/websocket-protocol-event-queue.js"></script>

    <!-- Test Suite -->
    <script>
        // Wait for everything to load
        window.addEventListener('load', function() {
            // Verify chai is loaded
            if (typeof chai === 'undefined') {
                document.getElementById('mocha').innerHTML = '<h1 style="color:red;">ERROR: Chai library failed to load</h1>';
                return;
            }

            // Setup mocha and chai
            mocha.setup('bdd');
            var expect = chai.expect;
            var assert = chai.assert;

            // Make available globally
            window.expect = expect;
            window.assert = assert;

        describe('WebsocketProtocolEventQueue Smoke Tests', function() {
            this.timeout(30000); // 30 second timeout for all tests

            let eventQueue;
            let consoleMessages = [];
            let pausedEvents = [];
            let resumedEvents = [];
            let scriptParsedEvents = [];

            // Helper to wait for an event
            function waitForEvent(eventMethod, timeout = 15000) {
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error(`Event timeout: ${eventMethod}`));
                    }, timeout);

                    const handler = (topic, message) => {
                        if (message.method === eventMethod) {
                            eventQueue.queue.unsubscribe(subscriptionId);
                            clearTimeout(timeoutId);
                            resolve(message.params);
                        }
                    };

                    const subscriptionId = eventQueue.queue.subscribe(eventMethod, handler);
                });
            }

            // Setup global event listeners to track events
            function setupEventListeners() {
                // Track console output
                eventQueue.runtimeController.on('Runtime.consoleAPICalled', (params) => {
                    consoleMessages.push(params);
                    console.log('Console message received:', params);
                });

                // Track debugger events
                eventQueue.debuggerController.on('Debugger.paused', (params) => {
                    pausedEvents.push(params);
                    console.log('Paused event received:', params.reason);
                });

                eventQueue.debuggerController.on('Debugger.resumed', (params) => {
                    resumedEvents.push(params);
                    console.log('Resumed event received');
                });

                eventQueue.debuggerController.on('Debugger.scriptParsed', (params) => {
                    scriptParsedEvents.push(params);
                });
            }

            // Helper to enable all domains
            async function enableDomains() {
                await eventQueue.consoleController.enable();
                await eventQueue.runtimeController.enable();
                await eventQueue.debuggerController.enable();
                await eventQueue.runtimeController.runIfWaitingForDebugger();
            }

            // Before each test: reset tracking arrays and create new event queue
            beforeEach(function() {
                consoleMessages = [];
                pausedEvents = [];
                resumedEvents = [];
                scriptParsedEvents = [];

                // Initialize the static event queue
                BaseDomainController.initialize('ws://localhost:8888');
                eventQueue = BaseDomainController.getEventQueue();
            });

            // After each test: close WebSocket if still open
            afterEach(function(done) {
                if (eventQueue && eventQueue.ws && eventQueue.ws.readyState === WebSocket.OPEN) {
                    eventQueue.ws.close();
                    setTimeout(done, 1000); // Wait for clean disconnect
                } else {
                    done();
                }
                // Reset static instance
                BaseDomainController.eventQueue = null;
            });

            describe('Basic Connection Tests', function() {
                it('should connect, enable domains, and disconnect', function(done) {
                    eventQueue.connect();

                    eventQueue.ws.addEventListener('open', async () => {
                        try {
                            console.log('WebSocket connected');

                            // Wait for Proxy.ready event
                            await waitForEvent('Proxy.ready', 5000);
                            console.log('Proxy ready');

                            // Enable domains
                            await enableDomains();
                            console.log('Domains enabled');

                            // Close connection
                            eventQueue.ws.close();
                            done();
                        } catch (err) {
                            done(err);
                        }
                    });

                    eventQueue.ws.addEventListener('error', (err) => {
                        done(err);
                    });
                });

                it('should connect, receive console output, and disconnect', function(done) {
                    this.timeout(15000);

                    eventQueue.connect();
                    setupEventListeners();

                    eventQueue.ws.addEventListener('open', async () => {
                        try {
                            console.log('WebSocket connected');

                            await waitForEvent('Proxy.ready', 5000);
                            await enableDomains();

                            console.log('Waiting for console output...');

                            // Wait for at least 3 console messages
                            await new Promise((resolve) => {
                                const checkInterval = setInterval(() => {
                                    if (consoleMessages.length >= 3) {
                                        clearInterval(checkInterval);
                                        resolve();
                                    }
                                }, 500);
                            });

                            console.log(`Received ${consoleMessages.length} console messages`);
                            expect(consoleMessages.length).to.be.at.least(3);

                            eventQueue.ws.close();
                            done();
                        } catch (err) {
                            done(err);
                        }
                    });

                    eventQueue.ws.addEventListener('error', (err) => {
                        done(err);
                    });
                });
            });

            describe('Pause and Resume Tests', function() {
                it('should connect, pause, resume, and disconnect', function(done) {
                    this.timeout(20000);

                    eventQueue.connect();
                    setupEventListeners();

                    eventQueue.ws.addEventListener('open', async () => {
                        try {
                            console.log('WebSocket connected');

                            await waitForEvent('Proxy.ready', 5000);
                            await enableDomains();

                            console.log('Pausing execution...');

                            // Send pause command and wait for paused event
                            const pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.pause();
                            const pausedData = await pausePromise;

                            console.log('Execution paused:', pausedData.reason);
                            expect(pausedEvents.length).to.equal(1);
                            expect(pausedData.reason).to.exist;

                            console.log('Resuming execution...');

                            // Resume and wait for resumed event
                            const resumePromise = waitForEvent('Debugger.resumed', 5000);
                            await eventQueue.debuggerController.resume();
                            await resumePromise;

                            console.log('Execution resumed');
                            expect(resumedEvents.length).to.equal(1);

                            eventQueue.ws.close();
                            done();
                        } catch (err) {
                            done(err);
                        }
                    });

                    eventQueue.ws.addEventListener('error', (err) => {
                        done(err);
                    });
                });

                it('should connect, pause, receive console during pause, resume, and disconnect', function(done) {
                    this.timeout(20000);

                    eventQueue.connect();
                    setupEventListeners();

                    eventQueue.ws.addEventListener('open', async () => {
                        try {
                            await waitForEvent('Proxy.ready', 5000);
                            await enableDomains();

                            const consoleCountBefore = consoleMessages.length;

                            // Pause
                            const pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.pause();
                            await pausePromise;

                            console.log('Paused - console messages:', consoleMessages.length);

                            // Resume
                            const resumePromise = waitForEvent('Debugger.resumed', 5000);
                            await eventQueue.debuggerController.resume();
                            await resumePromise;

                            // Wait for more console output after resume
                            await new Promise(resolve => setTimeout(resolve, 2000));

                            const consoleCountAfter = consoleMessages.length;
                            console.log('Resumed - console messages:', consoleCountAfter);

                            expect(consoleCountAfter).to.be.at.least(consoleCountBefore);

                            eventQueue.ws.close();
                            done();
                        } catch (err) {
                            done(err);
                        }
                    });

                    eventQueue.ws.addEventListener('error', (err) => {
                        done(err);
                    });
                });
            });

            describe('Step Command Tests', function() {
                it('should connect, pause, stepOver, and disconnect', function(done) {
                    this.timeout(20000);

                    eventQueue.connect();
                    setupEventListeners();

                    eventQueue.ws.addEventListener('open', async () => {
                        try {
                            await waitForEvent('Proxy.ready', 5000);
                            await enableDomains();

                            console.log('Pausing for stepOver test...');

                            // Pause
                            let pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.pause();
                            await pausePromise;

                            expect(pausedEvents.length).to.equal(1);
                            const firstPauseLocation = pausedEvents[0];
                            console.log('First pause location:', firstPauseLocation.callFrames[0].location);

                            console.log('Stepping over...');

                            // Step over - this resumes and immediately pauses at next line
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepOver();
                            await pausePromise;

                            expect(pausedEvents.length).to.equal(2);
                            const secondPauseLocation = pausedEvents[1];
                            console.log('Second pause location after stepOver:', secondPauseLocation.callFrames[0].location);

                            // Verify we moved to a different line
                            expect(secondPauseLocation.callFrames[0].location.lineNumber)
                                .to.not.equal(firstPauseLocation.callFrames[0].location.lineNumber);

                            // Resume to finish
                            await eventQueue.debuggerController.resume();

                            eventQueue.ws.close();
                            done();
                        } catch (err) {
                            done(err);
                        }
                    });

                    eventQueue.ws.addEventListener('error', (err) => {
                        done(err);
                    });
                });

                it('should connect, pause, stepInto, stepOut, and disconnect', function(done) {
                    this.timeout(30000);

                    eventQueue.connect();
                    setupEventListeners();

                    eventQueue.ws.addEventListener('open', async () => {
                        try {
                            await waitForEvent('Proxy.ready', 5000);
                            await enableDomains();

                            console.log('Waiting for script with function calls...');

                            // Wait for some execution to happen
                            await new Promise(resolve => setTimeout(resolve, 3000));

                            console.log('Pausing for step tests...');

                            // Pause
                            let pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.pause();
                            await pausePromise;

                            const initialDepth = pausedEvents[0].callFrames.length;
                            console.log('Initial call stack depth:', initialDepth);

                            // Step into - should go into a function
                            console.log('Stepping into...');
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepInto();
                            await pausePromise;

                            // Note: stepInto might or might not increase depth depending on where we paused
                            console.log('After stepInto, call stack depth:', pausedEvents[1].callFrames.length);

                            // Step out - should exit current function
                            console.log('Stepping out...');
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepOut();
                            await pausePromise;

                            const finalDepth = pausedEvents[2].callFrames.length;
                            console.log('After stepOut, call stack depth:', finalDepth);

                            // Resume to finish
                            await eventQueue.debuggerController.resume();

                            eventQueue.ws.close();
                            done();
                        } catch (err) {
                            done(err);
                        }
                    });

                    eventQueue.ws.addEventListener('error', (err) => {
                        done(err);
                    });
                });

                it('should connect, pause, execute all step commands in sequence, and disconnect', function(done) {
                    this.timeout(30000);

                    eventQueue.connect();
                    setupEventListeners();

                    eventQueue.ws.addEventListener('open', async () => {
                        try {
                            await waitForEvent('Proxy.ready', 5000);
                            await enableDomains();

                            // Wait for execution to start
                            await new Promise(resolve => setTimeout(resolve, 3000));

                            console.log('Starting comprehensive step test...');

                            // Pause
                            let pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.pause();
                            await pausePromise;
                            console.log('1. Paused');

                            // StepOver
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepOver();
                            await pausePromise;
                            console.log('2. StepOver completed');

                            // StepOver again
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepOver();
                            await pausePromise;
                            console.log('3. StepOver completed again');

                            // StepInto
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepInto();
                            await pausePromise;
                            console.log('4. StepInto completed');

                            // StepOut
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepOut();
                            await pausePromise;
                            console.log('5. StepOut completed');

                            // Resume
                            const resumePromise = waitForEvent('Debugger.resumed', 5000);
                            await eventQueue.debuggerController.resume();
                            await resumePromise;
                            console.log('6. Resumed');

                            // Verify we executed all steps
                            expect(pausedEvents.length).to.equal(5); // Initial pause + 4 steps
                            expect(resumedEvents.length).to.equal(1);

                            console.log('All step commands executed successfully');

                            eventQueue.ws.close();
                            done();
                        } catch (err) {
                            done(err);
                        }
                    });

                    eventQueue.ws.addEventListener('error', (err) => {
                        done(err);
                    });
                });
            });

            describe('Full User Session Tests', function() {
                it('should simulate complete debugging session: connect, console, pause, step multiple times, resume, disconnect', function(done) {
                    this.timeout(40000);

                    eventQueue.connect();
                    setupEventListeners();

                    eventQueue.ws.addEventListener('open', async () => {
                        try {
                            console.log('\n=== Starting full user session test ===\n');

                            // 1. Connect and enable
                            await waitForEvent('Proxy.ready', 5000);
                            await enableDomains();
                            console.log('✓ Connected and enabled domains');

                            // 2. Receive some console output
                            await new Promise((resolve) => {
                                const checkInterval = setInterval(() => {
                                    if (consoleMessages.length >= 3) {
                                        clearInterval(checkInterval);
                                        resolve();
                                    }
                                }, 500);
                            });
                            console.log(`✓ Received ${consoleMessages.length} console messages`);
                            expect(consoleMessages.length).to.be.at.least(3);

                            // 3. Pause execution
                            let pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.pause();
                            await pausePromise;
                            console.log('✓ Paused execution');

                            // 4. Step over twice
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepOver();
                            await pausePromise;
                            console.log('✓ First stepOver');

                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepOver();
                            await pausePromise;
                            console.log('✓ Second stepOver');

                            // 5. Step into
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepInto();
                            await pausePromise;
                            console.log('✓ StepInto');

                            // 6. Step out
                            pausePromise = waitForEvent('Debugger.paused', 10000);
                            await eventQueue.debuggerController.stepOut();
                            await pausePromise;
                            console.log('✓ StepOut');

                            // 7. Resume
                            const resumePromise = waitForEvent('Debugger.resumed', 5000);
                            await eventQueue.debuggerController.resume();
                            await resumePromise;
                            console.log('✓ Resumed execution');

                            // 8. Get more console output
                            const beforeResume = consoleMessages.length;
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            const afterResume = consoleMessages.length;
                            console.log(`✓ Console output after resume: ${afterResume - beforeResume} new messages`);

                            // 9. Verify everything worked
                            expect(pausedEvents.length).to.equal(5);
                            expect(resumedEvents.length).to.equal(1);
                            expect(afterResume).to.be.greaterThan(beforeResume);

                            console.log('\n=== Full user session completed successfully ===\n');
                            console.log('Summary:');
                            console.log(`  - Console messages: ${consoleMessages.length}`);
                            console.log(`  - Paused events: ${pausedEvents.length}`);
                            console.log(`  - Resumed events: ${resumedEvents.length}`);
                            console.log(`  - Scripts parsed: ${scriptParsedEvents.length}`);

                            eventQueue.ws.close();
                            done();
                        } catch (err) {
                            done(err);
                        }
                    });

                    eventQueue.ws.addEventListener('error', (err) => {
                        done(err);
                    });
                });
            });
        });

            // Run tests after everything is defined
            mocha.run();
        }); // End window.load event
    </script>

    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        #mocha {
            margin: 20px 0;
        }
    </style>
</body>
</html>