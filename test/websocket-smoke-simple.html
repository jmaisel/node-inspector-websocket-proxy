<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Smoke Tests</title>
    <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css">
</head>
<body>
    <div id="mocha"></div>

    <!-- Load testing frameworks first -->
    <script src="https://unpkg.com/mocha@10.2.0/mocha.js"></script>
    <script src="https://unpkg.com/chai@4.3.10/chai.js"></script>

    <!-- Load application code -->
    <script src="../client/regex-pubsub.js"></script>
    <script src="../client/inspector-constants.js"></script>
    <script src="../client/inspector-controllers.js"></script>
    <script src="../client/inspector-browser-proxy.js"></script>

    <script>
        // Wait for everything to load
        window.addEventListener('load', function() {
            // Verify chai is loaded
            if (typeof chai === 'undefined') {
                document.getElementById('mocha').innerHTML = '<h1 style="color:red;">ERROR: Chai library failed to load</h1>';
                return;
            }

            // Setup mocha and chai
            mocha.setup('bdd');
            var expect = chai.expect;
            var assert = chai.assert;

            // Make available globally
            window.expect = expect;
            window.assert = assert;

        describe('WebsocketProtocolEventQueue - Simple Smoke Tests', function() {
            this.timeout(30000);

            let eventQueue;

            // Helper to wait for WebSocket open
            function waitForOpen(ws, timeout = 5000) {
                return new Promise((resolve, reject) => {
                    if (ws.readyState === WebSocket.OPEN) {
                        resolve();
                        return;
                    }

                    const timer = setTimeout(() => {
                        reject(new Error('WebSocket open timeout'));
                    }, timeout);

                    ws.addEventListener('open', () => {
                        clearTimeout(timer);
                        resolve();
                    });

                    ws.addEventListener('error', (err) => {
                        clearTimeout(timer);
                        reject(new Error('WebSocket error: ' + err));
                    });
                });
            }

            // Helper to wait for proxy ready
            function waitForProxyReady(queue, timeout = 5000) {
                return new Promise((resolve, reject) => {
                    const timer = setTimeout(() => {
                        resolve(); // Don't fail if proxy ready doesn't come
                    }, timeout);

                    const subId = queue.queue.subscribe('Proxy.ready', () => {
                        clearTimeout(timer);
                        queue.queue.unsubscribe(subId);
                        resolve();
                    });
                });
            }

            beforeEach(function() {
                // Clean up any existing static instance
                if (BaseDomainController.eventQueue) {
                    if (BaseDomainController.eventQueue.ws) {
                        try {
                            BaseDomainController.eventQueue.ws.close();
                        } catch (e) {
                            console.warn('Error closing previous WebSocket:', e);
                        }
                    }
                    BaseDomainController.eventQueue = null;
                }

                // Initialize fresh instance
                eventQueue = BaseDomainController.initialize('ws://localhost:8888');
            });

            afterEach(function(done) {
                if (eventQueue && eventQueue.ws) {
                    if (eventQueue.ws.readyState === WebSocket.OPEN) {
                        eventQueue.ws.close();
                        setTimeout(done, 1000);
                    } else {
                        done();
                    }
                } else {
                    done();
                }

                // Clean up static instance
                BaseDomainController.eventQueue = null;
            });

            describe('Connection Tests', function() {
                it('should create event queue instance', function() {
                    expect(eventQueue).to.exist;
                    expect(eventQueue.queue).to.exist;
                    expect(eventQueue.consoleController).to.exist;
                    expect(eventQueue.runtimeController).to.exist;
                    expect(eventQueue.debuggerController).to.exist;
                });

                it('should connect to WebSocket server', async function() {
                    eventQueue.connect();

                    expect(eventQueue.ws).to.exist;
                    expect(eventQueue.ws.url).to.equal('ws://localhost:8888/');

                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    expect(eventQueue.ws.readyState).to.equal(WebSocket.OPEN);
                });

                it('should enable Console domain', async function() {
                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    const result = await eventQueue.consoleController.enable();
                    console.log('Console.enable result:', result);
                    // No error means success
                });

                it('should enable Runtime domain', async function() {
                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    const result = await eventQueue.runtimeController.enable();
                    console.log('Runtime.enable result:', result);
                    // No error means success
                });

                it('should enable Debugger domain', async function() {
                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    const result = await eventQueue.debuggerController.enable();
                    console.log('Debugger.enable result:', result);
                    // No error means success
                });

                it('should enable all domains and runIfWaitingForDebugger', async function() {
                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();

                    console.log('All domains enabled successfully');
                });
            });

            describe('Console Output Tests', function() {
                it('should receive console output from debugged script', async function() {
                    this.timeout(15000);

                    const consoleMessages = [];

                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    // Set up listener BEFORE enabling domains
                    eventQueue.runtimeController.on('Runtime.consoleAPICalled', (params) => {
                        consoleMessages.push(params);
                        console.log('Console output:', params);
                    });

                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();

                    // Wait for console messages
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (consoleMessages.length >= 3) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 500);

                        // Timeout after 10 seconds
                        setTimeout(() => {
                            clearInterval(checkInterval);
                            resolve();
                        }, 10000);
                    });

                    console.log(`Received ${consoleMessages.length} console messages`);
                    expect(consoleMessages.length).to.be.at.least(1);
                });
            });

            describe('Debugger Control Tests', function() {
                it('should pause execution', async function() {
                    this.timeout(20000);

                    const pausedEvents = [];

                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    // Set up listener
                    eventQueue.debuggerController.on('Debugger.paused', (params) => {
                        pausedEvents.push(params);
                        console.log('Paused:', params.reason);
                    });

                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();

                    // Wait a bit for script to start running
                    await new Promise(resolve => setTimeout(resolve, 2000));

                    // Send pause command
                    await eventQueue.debuggerController.pause();

                    // Wait for paused event
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length > 0) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);

                        setTimeout(() => {
                            clearInterval(checkInterval);
                            resolve();
                        }, 10000);
                    });

                    console.log(`Received ${pausedEvents.length} paused events`);
                    expect(pausedEvents.length).to.be.at.least(1);
                });

                it('should pause and resume', async function() {
                    this.timeout(20000);

                    const pausedEvents = [];
                    const resumedEvents = [];

                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    // Set up listeners
                    eventQueue.debuggerController.on('Debugger.paused', (params) => {
                        pausedEvents.push(params);
                        console.log('Paused:', params.reason);
                    });

                    eventQueue.debuggerController.on('Debugger.resumed', (params) => {
                        resumedEvents.push(params);
                        console.log('Resumed');
                    });

                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();

                    // Wait for script to start
                    await new Promise(resolve => setTimeout(resolve, 2000));

                    // Pause
                    await eventQueue.debuggerController.pause();

                    // Wait for pause
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length > 0) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    });

                    expect(pausedEvents.length).to.equal(1);

                    // Resume
                    await eventQueue.debuggerController.resume();

                    // Wait for resume
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (resumedEvents.length > 0) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);

                        setTimeout(() => {
                            clearInterval(checkInterval);
                            resolve();
                        }, 5000);
                    });

                    expect(resumedEvents.length).to.equal(1);
                });

                it('should pause, receive console output during pause, and resume', async function() {
                    this.timeout(20000);

                    const pausedEvents = [];
                    const resumedEvents = [];
                    const consoleMessages = [];

                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    // Set up listeners
                    eventQueue.debuggerController.on('Debugger.paused', (params) => {
                        pausedEvents.push(params);
                        console.log('Paused:', params.reason);
                    });

                    eventQueue.debuggerController.on('Debugger.resumed', (params) => {
                        resumedEvents.push(params);
                        console.log('Resumed');
                    });

                    eventQueue.runtimeController.on('Runtime.consoleAPICalled', (params) => {
                        consoleMessages.push(params);
                        console.log('Console output:', params);
                    });

                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();

                    // Wait for script to start and get some console output
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    const consoleCountBefore = consoleMessages.length;

                    // Pause
                    await eventQueue.debuggerController.pause();

                    // Wait for pause
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length > 0) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    });

                    console.log('Paused - console messages:', consoleMessages.length);

                    // Resume
                    await eventQueue.debuggerController.resume();

                    // Wait for resume
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (resumedEvents.length > 0) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    });

                    // Wait for more console output after resume
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    const consoleCountAfter = consoleMessages.length;
                    console.log('Resumed - console messages:', consoleCountAfter);

                    expect(consoleCountAfter).to.be.at.least(consoleCountBefore);
                });
            });

            describe('Step Command Tests', function() {
                // Helper to wait for a paused event
                async function waitForPaused(pausedEvents, expectedCount, timeout = 10000) {
                    return new Promise((resolve, reject) => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length >= expectedCount) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);

                        setTimeout(() => {
                            clearInterval(checkInterval);
                            if (pausedEvents.length >= expectedCount) {
                                resolve();
                            } else {
                                reject(new Error(`Timeout waiting for pause event ${expectedCount}`));
                            }
                        }, timeout);
                    });
                }

                it('should pause and stepOver', async function() {
                    this.timeout(20000);

                    const pausedEvents = [];

                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    // Set up listener
                    eventQueue.debuggerController.on('Debugger.paused', (params) => {
                        pausedEvents.push(params);
                        console.log('Paused at line:', params.callFrames[0]?.location?.lineNumber);
                    });

                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();

                    // Wait for script to start
                    await new Promise(resolve => setTimeout(resolve, 2000));

                    // Pause
                    await eventQueue.debuggerController.pause();
                    await waitForPaused(pausedEvents, 1);

                    const firstLine = pausedEvents[0].callFrames[0]?.location?.lineNumber;
                    console.log('First pause at line:', firstLine);

                    // StepOver
                    await eventQueue.debuggerController.stepOver();
                    await waitForPaused(pausedEvents, 2);

                    const secondLine = pausedEvents[1].callFrames[0]?.location?.lineNumber;
                    console.log('After stepOver at line:', secondLine);

                    expect(pausedEvents.length).to.equal(2);
                    expect(secondLine).to.not.equal(firstLine);

                    // Resume to finish
                    await eventQueue.debuggerController.resume();
                });

                it('should pause, stepInto, and stepOut', async function() {
                    this.timeout(25000);

                    const pausedEvents = [];

                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    // Set up listener
                    eventQueue.debuggerController.on('Debugger.paused', (params) => {
                        pausedEvents.push(params);
                        console.log('Paused - call stack depth:', params.callFrames?.length);
                    });

                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();

                    // Wait for script to execute some functions
                    await new Promise(resolve => setTimeout(resolve, 3000));

                    // Pause
                    await eventQueue.debuggerController.pause();
                    await waitForPaused(pausedEvents, 1);

                    console.log('Initial call stack depth:', pausedEvents[0].callFrames?.length);

                    // StepInto
                    await eventQueue.debuggerController.stepInto();
                    await waitForPaused(pausedEvents, 2);

                    console.log('After stepInto, call stack depth:', pausedEvents[1].callFrames?.length);

                    // StepOut
                    await eventQueue.debuggerController.stepOut();
                    await waitForPaused(pausedEvents, 3);

                    console.log('After stepOut, call stack depth:', pausedEvents[2].callFrames?.length);

                    expect(pausedEvents.length).to.equal(3);

                    // Resume to finish
                    await eventQueue.debuggerController.resume();
                });

                it('should execute all step commands in sequence', async function() {
                    this.timeout(30000);

                    const pausedEvents = [];
                    const resumedEvents = [];

                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    // Set up listeners
                    eventQueue.debuggerController.on('Debugger.paused', (params) => {
                        pausedEvents.push(params);
                    });

                    eventQueue.debuggerController.on('Debugger.resumed', (params) => {
                        resumedEvents.push(params);
                    });

                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();

                    // Wait for execution to start
                    await new Promise(resolve => setTimeout(resolve, 3000));

                    console.log('Starting comprehensive step test...');

                    // Pause
                    await eventQueue.debuggerController.pause();
                    await waitForPaused(pausedEvents, 1);
                    console.log('1. Paused');

                    // StepOver
                    await eventQueue.debuggerController.stepOver();
                    await waitForPaused(pausedEvents, 2);
                    console.log('2. StepOver completed');

                    // StepOver again
                    await eventQueue.debuggerController.stepOver();
                    await waitForPaused(pausedEvents, 3);
                    console.log('3. StepOver completed again');

                    // StepInto
                    await eventQueue.debuggerController.stepInto();
                    await waitForPaused(pausedEvents, 4);
                    console.log('4. StepInto completed');

                    // StepOut
                    await eventQueue.debuggerController.stepOut();
                    await waitForPaused(pausedEvents, 5);
                    console.log('5. StepOut completed');

                    // Resume
                    await eventQueue.debuggerController.resume();
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (resumedEvents.length >= 5) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                        setTimeout(() => {
                            clearInterval(checkInterval);
                            resolve();
                        }, 5000);
                    });
                    console.log('6. Resumed');

                    // Verify we executed all steps
                    // Note: Each step command (stepOver, stepInto, stepOut) fires a Debugger.resumed
                    // event before the next Debugger.paused event, so we get 5 resumed events total:
                    // 4 from the step commands + 1 from the final resume()
                    expect(pausedEvents.length).to.equal(5);
                    expect(resumedEvents.length).to.equal(5);

                    console.log('All step commands executed successfully');
                });
            });

            describe('Full User Session Test', function() {
                it('should simulate complete debugging session', async function() {
                    this.timeout(40000);

                    const consoleMessages = [];
                    const pausedEvents = [];
                    const resumedEvents = [];

                    eventQueue.connect();
                    await waitForOpen(eventQueue.ws);
                    await waitForProxyReady(eventQueue);

                    console.log('\n=== Starting full user session test ===\n');

                    // Set up all listeners
                    eventQueue.runtimeController.on('Runtime.consoleAPICalled', (params) => {
                        consoleMessages.push(params);
                    });

                    eventQueue.debuggerController.on('Debugger.paused', (params) => {
                        pausedEvents.push(params);
                    });

                    eventQueue.debuggerController.on('Debugger.resumed', (params) => {
                        resumedEvents.push(params);
                    });

                    // 1. Connect and enable
                    await eventQueue.consoleController.enable();
                    await eventQueue.runtimeController.enable();
                    await eventQueue.debuggerController.enable();
                    await eventQueue.runtimeController.runIfWaitingForDebugger();
                    console.log('✓ Connected and enabled domains');

                    // 2. Receive console output
                    await new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            if (consoleMessages.length >= 3) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 500);
                        setTimeout(() => {
                            clearInterval(checkInterval);
                            resolve();
                        }, 10000);
                    });
                    console.log(`✓ Received ${consoleMessages.length} console messages`);
                    expect(consoleMessages.length).to.be.at.least(1);

                    // 3. Pause execution
                    await eventQueue.debuggerController.pause();
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length >= 1) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    });
                    console.log('✓ Paused execution');

                    // 4. Step over twice
                    await eventQueue.debuggerController.stepOver();
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length >= 2) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    });
                    console.log('✓ First stepOver');

                    await eventQueue.debuggerController.stepOver();
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length >= 3) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    });
                    console.log('✓ Second stepOver');

                    // 5. Step into
                    await eventQueue.debuggerController.stepInto();
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length >= 4) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    });
                    console.log('✓ StepInto');

                    // 6. Step out
                    await eventQueue.debuggerController.stepOut();
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (pausedEvents.length >= 5) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                    });
                    console.log('✓ StepOut');

                    // 7. Resume
                    await eventQueue.debuggerController.resume();
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (resumedEvents.length >= 5) {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 100);
                        setTimeout(() => {
                            clearInterval(checkInterval);
                            resolve();
                        }, 5000);
                    });
                    console.log('✓ Resumed execution');

                    // 8. Get more console output
                    const beforeResume = consoleMessages.length;
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    const afterResume = consoleMessages.length;
                    console.log(`✓ Console output after resume: ${afterResume - beforeResume} new messages`);

                    // 9. Verify everything worked
                    // Note: Each step command fires a Debugger.resumed event before pausing again,
                    // so we get 5 resumed events: 4 from step commands + 1 from final resume()
                    expect(pausedEvents.length).to.equal(5);
                    expect(resumedEvents.length).to.equal(5);

                    console.log('\n=== Full user session completed successfully ===\n');
                    console.log('Summary:');
                    console.log(`  - Console messages: ${consoleMessages.length}`);
                    console.log(`  - Paused events: ${pausedEvents.length}`);
                    console.log(`  - Resumed events: ${resumedEvents.length}`);
                });
            });
        });

            // Run tests after everything is defined
            mocha.run();
        }); // End window.load event
    </script>
</body>
</html>
